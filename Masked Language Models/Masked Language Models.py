# -*- coding: utf-8 -*-
"""Chapter_11_Masked_Language_Models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pbvYWS_YQyFmFMh1WLIzVo6jw_hc3UJU
"""

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt
from typing import Optional, Any, List, Tuple, Dict
import math
from dataclasses import dataclass
import time

# Seeds
np.random.seed(42)
torch.manual_seed(42)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("Using", device )

"""## NumPy Indexing in Multi-Dim: Implicit Rules

Consider a tensor:
```python
x.shape == (2, 3, 4) # [seq_len, n_heads, d_head]
````

Visual layout:

```
[
  [   # first axis-0 element (token 0)
    [x000, x001, x002, x003],   # head 0
    [x010, x011, x012, x013],   # head 1
    [x020, x021, x022, x023]    # head 2
  ],

  [   # second axis-0 element (token 1)
    [x100, x101, x102, x103],   # head 0
    [x110, x111, x112, x113],   # head 1
    [x120, x121, x122, x123]    # head 2
  ]
]
```

---

### 1. Missing slices are implied

If fewer slices are provided than the number of dimensions, NumPy assumes full slices (`:`) for the remaining axes.

```python
x[:, 1]        # (2, 4), equivalent to x[:, 1, :]
```

Result:

```
[
  [x010, x011, x012, x013],   # token 0, head 1
  [x110, x111, x112, x113]    # token 1, head 1
]
```

```python
x[0]          # (3, 4), equivalent to x[0, :, :]
```

Result:

```
[
  [x000, x001, x002, x003],   # head 0
  [x010, x011, x012, x013],   # head 1
  [x020, x021, x022, x023]    # head 2
]
```

---

### 2. Integer indices remove dimensions

An integer index selects a single element along that axis and drops the dimension.

```python
x[:, :, 2]    # (2, 3), axis 2 removed
```

Result:

```
[
  [x002, x012, x022],   # token 0, all heads
  [x102, x112, x122]    # token 1, all heads
]
```

---

### 3. Slice (`:`) keeps dimensions

Using a slice preserves the axis length.

```python
x[:, 1:2, :].shape   # (2, 1, 4)
```

Result (note the extra axis of length 1):

```
[
  [
    [x010, x011, x012, x013]   # head 1 kept as axis length 1
  ],
  [
    [x110, x111, x112, x113]
  ]
]
```

---

### 4. Trailing axes can be omitted

If only the first axes are specified, NumPy assumes `:` for all remaining axes.

```python
x[0]       # (3, 4), equivalent to x[0, :, :]
```

Result (same as above for token 0):

```
[
  [x000, x001, x002, x003],
  [x010, x011, x012, x013],
  [x020, x021, x022, x023]
]
```

---

### 5. Ellipsis (`...`)

Ellipsis expands to the required number of `:` to cover missing dimensions.

```python
x[..., 2]   # (2, 3), equivalent to x[:, :, 2]
```

Result:

```
[
  [x002, x012, x022],   # token 0
  [x102, x112, x122]    # token 1
]
```

```python
x[0, ...]   # (3, 4), equivalent to x[0, :, :]
```

Result:

```
[
  [x000, x001, x002, x003],
  [x010, x011, x012, x013],
  [x020, x021, x022, x023]
]
```

# Vanilla Bidirectional Attention
"""

class BidirectionalAttention:
  """Bidirectional attention without causal mask"""

  def __init__(self, d_model:int, n_heads:int):
    self.d_model = d_model
    self.n_heads = n_heads

    assert d_model % n_heads == 0, "d_model must be divisible by n_heads"


    self.d_head = d_model//n_heads

    # Weight matrices
    self.W_Q = np.random.randn(d_model, d_model) * 0.02
    self.W_K = np.random.randn(d_model, d_model) * 0.02
    self.W_V = np.random.randn(d_model, d_model) * 0.02
    self.W_O = np.random.randn(d_model, d_model) * 0.02

    print(f"Bidirectional attention: d_model={d_model}, n_heads={n_heads}, d_head={self.d_head}")

  def forward(self, x:np.ndarray ) -> Tuple[np.ndarray, np.ndarray]:
    """
    x: [seq_len, d_model]
    Returns: sequence output [seq_len, d_model], attention [seq_len, seq_len]
    """

    seq_len = x.shape[0]

    # Compute Q, K, V
    Q = x @ self.W_Q # [seq_len, d_model]
    K = x @ self.W_K # [seq_len, d_model]
    V = x @ self.W_V # [seq_len, d_model]
    print(f"\nQ,K,V shapes: {Q.shape}")

    # Reshape for the multi-head, needs [L, h, d_k]
    Q = Q.reshape(seq_len, self.n_heads, self.d_head)  #  n_heads * d_head = d_model
    K = K.reshape(seq_len, self.n_heads, self.d_head)
    V = V.reshape(seq_len, self.n_heads, self.d_head)

    # Compute attention without causal masking
    scores = np.zeros((self.n_heads, seq_len, seq_len))

    for head in range(self.n_heads):
      QK = Q[:, head] @ K[:,head].T # [L, d_k] @ [d_k, L] = [L, L]
      scores[head] = QK / np.sqrt(self.d_head) # normalization by sqrt of d_k
      print(f"Head {head}: QK^T range [{QK.min():.2f}, {QK.max():.2f}]")


    # Without Masking
    # Sofmax directly
    attention = np.exp(scores - scores.max(axis=-1, keepdims=True)) # Stability and avoid overflow for large values
    attention = attention / attention.sum(axis=-1, keepdims=True)
    print(f"Attention shape: {attention.shape}, no causal mask applied")

    # Attention to Values Matrix
    output = np.zeros((seq_len, self.d_model))
    for head in range(self.n_heads):
      head_out = attention[head] @ V[:,head] # [L, L] @ [L, d_k] = [L, d_k]
      start_idx = head * self.d_head
      end_idx = (head+1) * self.d_head
      output[:, start_idx :end_idx] = head_out

    # Output Proj
    output = output @ self.W_O
    print(f"Output shape: {output.shape}")

    return output, attention.mean(axis=0) # Average attention over heads

"""## Test Bidirectional vs Causal"""

seq_len, d_model = 6, 64
x = np.random.randn(seq_len, d_model)

bidirectional_attn = BidirectionalAttention(d_model, n_heads=4)
output, attn_weights = bidirectional_attn.forward(x)


# Visualize bidirectional attention pattern
plt.figure(figsize=(10, 4))
plt.subplot(1, 2, 1)
plt.imshow(attn_weights, cmap='Blues')
plt.colorbar()
plt.title('Bidirectional Attention\n(can attend to all positions)')
plt.xlabel('Keys')
plt.ylabel('Queries')

# Show causal mask for comparison
plt.subplot(1, 2, 2)
causal_mask = np.tril(np.ones((seq_len, seq_len)))
plt.imshow(causal_mask, cmap='Blues')
plt.colorbar()
plt.title('Causal Mask Pattern\n(only attend to past)')
plt.xlabel('Keys')
plt.ylabel('Queries')
plt.tight_layout()
plt.show()

print(f"\nKey difference: Position 0 can attend to position 5: {attn_weights[0, 5]:.3f}")
print(f"In causal attention, this would be 0 (masked)")

"""#PyTorch Bidirectional Transformer Block"""

class BidirectionalTransformerBlock(nn.Module):
  """BERT-style transformer block without causal masking"""

  def __init__(self, d_model: int, n_heads: int, d_ff: int = None, dropout:float = 0.1):
    super().__init__()

    self.d_model = d_model
    self.n_heads = n_heads

    # Multi-head attention wihout maskin
    self.attention = nn.MultiheadAttention(self.d_model, n_heads, dropout=dropout, batch_first=True)

    # Feedforward Layer
    d_ff = d_ff or 4 * d_model # Usually FFN = 4 * hidden state

    self.ffn = nn.Sequential(
        nn.Linear(d_model, d_ff),
        nn.GELU(),    # Standard activation function in BERT, not ReLU
        nn.Dropout(dropout),
        nn.Linear(d_ff, d_model)
        )

    # Layer Norm (post-norm)
    self.ln1 = nn.LayerNorm(d_model)
    self.ln2 = nn.LayerNorm(d_model)
    self.dropout = nn.Dropout(dropout)

  def forward(self, x:torch.Tensor, padding_mask: Optional[torch.Tensor] = None):
    """
    x:  [batch, seq_len, d_model]
    padding_mask: [batch,seq_len] - True for padded positions
    """
    print(f"\nInput: {x.shape}")

    # Self attention without Causal Mask
    attn_out, attn_weights = self.attention(x, x, x,    # Q,K,V
                                            key_padding_mask = padding_mask, # Shape: [batch, seq_len]. tells the attention which tokens are padding and should not contribute to the attention output. Example: padding_mask = torch.tensor([[False, False, True, True]])  # batch=1, seq_len=4
                                            need_weights = True,  # whether the function should return the attention weights along with the output
                                            attn_mask = None # No causal mask
                                            )
    print(f"Attention output: {attn_out.shape}, weights: {attn_weights.shape}")

    # Residual connection + layer norm
    x = self.ln1(x + self.dropout(attn_out))
    print(f"After LN1: mean={x.mean():.3f}, std={x.std():.3f}")

    # Feedforward
    ffn_out = self.ffn(x)

    # Residual connection + layer norm
    x = self.ln2(x + self.dropout(ffn_out))
    print(f"After LN2: mean={x.mean():.3f}, std={x.std():.3f}")

    return x, attn_weights

"""## Test with mixed precision and torch.compile"""

model = BidirectionalTransformerBlock(d_model=256, n_heads=8).to(device)
print(f"Parameters: {sum(param.numel() for param in model.parameters()):,}")

# Mixed precision
from torch.cuda.amp import autocast
x = torch.randn(2,20,256).to(device)

with autocast(dtype=torch.bfloat16) if device.type == "cuda" else torch.no_grad():
  output, attn = model(x)
  print(f"\nWith bfloat16: output dtype={output.dtype}")


# Compiling
if hasattr(torch, 'compile'):
  model_compiled = torch.compile(model, mode='reduce-overhead') # Best option for small models
  print("Model compiled with torch.compile")

"""# HuggingFace BERT MLM Training"""

@dataclass
class BERTPretrainingBatch:
  """Batch for BERT pretraining with MLM + NSP"""

  input_ids: torch.Tensor
  attention_mask: torch.Tensor
  token_type_ids: torch.Tensor # segment for embeddings
  mlm_labels: torch.Tensor
  nsp_labels: torch.Tensor

class BERTPretrainer(nn.Module):
  """BERT model with MLM and NSP heads"""

  def __init__(self, config):
    super().__init__()
    self.config = config

    # Token embeddings + position + segment
    self.embeddings = nn.ModuleDict({
        'token':nn.Embedding(config['vocab_size'], config['d_model']),
        'position': nn.Embedding(config['max_position'], config['d_model']),
        'segment': nn.Embedding(2, config['d_model']), # 2 segments for Next Sent Pred
    })

    # Transformer blocks
    self.blocks = nn.ModuleList([
        BidirectionalTransformerBlock(
            config['d_model'],
            config['n_heads'],
            config['d_ff']
        ) for _ in range(config['n_layers'])
    ])

    # MLM head
    self.mlm_head = nn.Sequential(
        nn.Linear(config['d_model'], config['d_model']),
        nn.GELU(),
        nn.LayerNorm(config['d_model']),
        nn.Linear(config['d_model'], config['vocab_size'])
    )

    # NSP head (binary classification)
    self.nsp_head = nn.Sequential(
        nn.Linear(config['d_model'], config['d_model']),
        nn.Tanh(),
        nn.Linear(config['d_model'], 2)
    )

    print(f"BERT Pretrainer initialized: {sum(p.numel() for p in self.parameters()):,} params")


  def forward(self, batch: BERTPretrainingBatch):

    # Combine embeddings
    x = self.embeddings['token'](batch.input_ids)
    positions = torch.arange(batch.input_ids.size(1), device=batch.input_ids.device)
    x = x + self.embeddings['position'](positions)
    x = x + self.embeddings['segment'](batch.token_type_ids)

    print(f"Embeddings: {x.shape}, norm={x.norm(dim=-1).mean():.3f}")


    # Pass through transformer blocks
    for i, block in enumerate(self.blocks):
      x, _ = block(x)
      if i == 0:
        print(f"After block {i}: {x.shape}")

    # MLM prediction for all the tokens
    mlm_logits = self.mlm_head(x) # shape [batch, seq_len, vocab_size]
    print(f"MLM logits: {mlm_logits.shape}")

    # NSP pred from [CLS] token (postion 0)
    cls_hidden = x[:, 0] # [batch, d_model]
    nsp_logits = self.nsp_head(cls_hidden) # [batch, 2]
    print(f"NSP logits: {nsp_logits.shape}")

    # Compute losses
    mlm_loss = F.cross_entropy(
        mlm_logits.view(-1, self.config['vocab_size']),
        batch.mlm_labels.view(-1),
        ignore_index = -100
    )

    nsp_loss = F.cross_entropy(nsp_logits, batch.nsp_labels)


    total_loss = mlm_loss + nsp_loss
    print(f"MLM loss: {mlm_loss:.3f}, NSP loss: {nsp_loss:.3f}, Total: {total_loss:.3f}")


    return {'loss': total_loss, 'mlm_loss': mlm_loss, 'nsp_loss': nsp_loss}

"""### Combined training test"""

config = {
  'vocab_size': 1000,
  'd_model': 256,
  'n_heads': 8,
  'd_ff': 1024,
  'n_layers': 2,
  'max_position': 128
}


model = BERTPretrainer(config).to(device)

# Create dummy batch
batch = BERTPretrainingBatch(
  input_ids=torch.randint(0, 1000, (4, 32)).to(device),
  attention_mask=torch.ones(4, 32).to(device),
  token_type_ids=torch.cat([torch.zeros(4, 16), torch.ones(4, 16)], dim=1).long().to(device),
  mlm_labels=torch.full((4, 32), -100).to(device),
  nsp_labels=torch.randint(0, 2, (4,)).to(device)
)

# Set some MLM labels
batch.mlm_labels[:, [5, 10, 15]] = torch.randint(0, 1000, (4, 3)).to(device)

# Forward pass with gradient accumulation
optimizer = torch.optim.AdamW(model.parameters(), lr=1e-4)

for step in range(2):
  print(f"\nStep {step}:")
  output = model(batch)
  loss = output['loss'] / 2  # Gradient accumulation
  loss.backward()

  if step % 2 == 1:  # Accumulate 2 steps
    optimizer.step()
    optimizer.zero_grad()
    print("Weights updated after gradient accumulation")

"""# Contextual Embeddings and Anisotropy Computation"""

class ContextualEmbeddingExtractor:
  """Extract and analyze contexttual embeddings"""

  def __init__(self, n_layers: int, d_model: int):
    self.n_layers = n_layers
    self.d_model = d_model

  def extract_token_embeddings(self, hidden_states: List[np.ndarray], layer_indices: List[int] = None) -> np.ndarray:
    """
    Extract contextual embeddings from specified layers
    hidden_states: List of [seq_len, d_model] arrays from each layer
    """

    if layer_indices is None:
      # Defualt: using the average of the 4 last layers (common for bert), this creates a more robust representation, leveraging the hierarchical nature of the transformer representation, where diff layers capture diff semantic and linguistic properties :)
      layer_indices = list(range(max(0, len(hidden_states) -4), len(hidden_states)))

    print(f"Extracting from layers: {layer_indices}")

    # Stack selected layers
    selected = [hidden_states[i] for i in layer_indices]
    stacked = np.stack(selected, axis=0) # [n_layers, seq_len, d_model]
    print(f"Stacked shape: {stacked.shape}")


    # Average across layers
    avg_embedding = stacked.mean(axis=0) # [seq_len, d_model]
    print(f"Averaged embedding: {avg_embedding.shape}")

    return avg_embedding


  def compute_anisotropy(self, embeddings: np.ndarray) -> float:
    """
    Compute anisotropy (average cosine simiarity between random pairs)
    High anisotropy is the same as having the vectors pointing to the same direction in embeding space.
    Having isotropy instead is what we need, so that the vectors are pointing in all the directions, and not a single one (a single token).
    Anisotropy occurs bcs in all the embeddings there are always some few dimensions that dominate and for which every token will have a very high value, so they end up pointing to similar points
    The solution is to standardize the embeddings: substract the mean and divide by the stdev
    """

    n_samples = min(100, len(embeddings))
    indices= np.random.choice(len(embeddings), n_samples, replace=False)
    sampled = embeddings[indices] # extracted the sampled embeddings

    # compute pairwise cosines
    norms = np.linalg.norm(sampled, axis=1, keepdims=True)

    normalized = sampled/(norms + 1e-10) # [n_samples, d_model]
    print("normalized: \n", normalized ,"\n")


    # For normalized vectors, dot product = cosine similarity
    cosine_matrix = normalized @ normalized.T  # [n_samples, n_samples]  A symmetric matrix where each entry is the cosine similarity between two vectors (diagonal = 1.0 for self-similarity).
    print("cosine_matrix: \n", cosine_matrix ,"\n")

    # Averaging off-diagonal elements
    mask = 1 - np.eye(n_samples) # Create mask: 1s everywhere except diagonal (which has 0s). The np.eye creates identity matrix with 1s on diagonal
    print("mask: \n", mask ,"\n")


    # Element-wise multiplying the cosine_matrix with the mask, zeroing out diagonal
    # Then sum all remaining values and divide by count of 1s in mask.
    avg_cosine = (cosine_matrix * mask).sum()/mask.sum() # This measures how similar vectors are on average

    print(f"Anisotropy: {avg_cosine:.3f} (0=isotropic, 1=anisotropic)")
    return avg_cosine


  def standardize_embeddings(self, embeddings: np.ndarray) -> np.ndarray:
    """Standardize embeddings to reduce the anisotropy"""

    # Compute mean and std across al embeddings
    mu = embeddings.mean(axis = 0)  # [d_model]
    sigma = embeddings.std(axis=0) # [d_model]

    print(f"Mean norm: {np.linalg.norm(mu):.3f}")
    print(f"Std range: [{sigma.min():.3f}, {sigma.max():.3f}]")

    # Standardize: z = (x - mean) / std
    standardized = (embeddings -mu) / (sigma + 1e-10)
    print(f"After standardization: mean={standardized.mean():.3f}, std={standardized.std():.3f}")

    return standardized

"""### Test contextual embedding extraction"""

extractor = ContextualEmbeddingExtractor(n_layers=12, d_model=256)

# Simulate hidden states from 12 layers
seq_len = 20
hidden_states = [np.random.randn(seq_len, 256) for _ in range(12)]

# Extract embeddings
embeddings = extractor.extract_token_embeddings(hidden_states)

# Check anisotropy
anisotropy_before = extractor.compute_anisotropy(embeddings)

# Standardize to reduce anisotropy
standardized = extractor.standardize_embeddings(embeddings)


anisotropy_after = extractor.compute_anisotropy(standardized)

print(f"\nAnisotropy reduction: {anisotropy_before:.3f} -> {anisotropy_after:.3f}")

"""#  Word Sense Disambiguation with Contextual Embeddings"""

class NearestNeighborWSD:
  """Word sense disambiguation using contextual embeddigns"""

  def __init__(self):
    self.sense_embeddings = {} # sense_id -> embedding
    self.sense_examples = {}   # sense_id -> example sentences

  def create_sense_embeddings(self, labeled_examples: List[Tuple[str, str, np.ndarray]]):
    """
    Create sense embeddings from labeled examples
    labeled_examples: List of (word, sense_id, context_embedding)
    """

    sense_vectors = {}

    for word, sense_id, embedding in labeled_examples:
      if sense_id not in sense_vectors:
        sense_vectors[sense_id] = []
        self.sense_examples[sense_id] = []

      sense_vectors[sense_id].append(embedding)
      self.sense_examples[sense_id].append(word)


    # Average embedding per sense
    for sense_id, vectors in sense_vectors.items():
      self.sense_embeddings[sense_id] = np.mean(vectors, axis=0)
      print(f"Sense '{sense_id}': {len(vectors)} examples, embedding shape {self.sense_embeddings[sense_id].shape}")


  def disambiguate(self, target_embedding:np.ndarray, word:str) -> str:
    """
    Find nearest sense for the target word
    """

    best_sense = None
    best_similarity = -1

    # Compute cosine similarity with each sense
    target_norm = target_embedding / (np.linalg.norm(target_embedding) + 1e-10) # Scaling dot product with the norms to avoid the effect of those too large values


    for sense_id, sense_emb in self.sense_embeddings.items():
      sense_norm = sense_emb / (np.linalg.norm(sense_emb) + 1e-10)
      similarity = np.dot(target_norm, sense_norm)
      print(f"Similarity to '{sense_id}': {similarity:.3f}")

      if similarity > best_similarity:
        best_similarity = similarity
        best_sense = sense_id


    print(f"\nPredicted sense: '{best_sense}' (similarity: {best_similarity:.3f})")
    return best_sense

"""# Test Nearest Neighbor Word Sense Disambiguation

"""

wsd = NearestNeighborWSD()

# Create more diverse sense embeddings for 'bank' with 3 senses
bank_examples = [
    # Financial sense cluster (more examples for better centroid)
    ("bank", "bank_financial", np.random.randn(256) * 0.3 + np.array([1.0, 0.5] + [0] * 254)),
    ("bank", "bank_financial", np.random.randn(256) * 0.3 + np.array([1.2, 0.4] + [0] * 254)),
    ("bank", "bank_financial", np.random.randn(256) * 0.3 + np.array([0.9, 0.6] + [0] * 254)),
    ("bank", "bank_financial", np.random.randn(256) * 0.3 + np.array([1.1, 0.3] + [0] * 254)),

    # River sense cluster
    ("bank", "bank_river", np.random.randn(256) * 0.3 + np.array([-1.0, 0.8] + [0] * 254)),
    ("bank", "bank_river", np.random.randn(256) * 0.3 + np.array([-0.9, 1.0] + [0] * 254)),
    ("bank", "bank_river", np.random.randn(256) * 0.3 + np.array([-1.1, 0.7] + [0] * 254)),
    ("bank", "bank_river", np.random.randn(256) * 0.3 + np.array([-0.8, 0.9] + [0] * 254)),

    # Tilt/lean sense cluster (e.g., "bank the airplane")
    ("bank", "bank_tilt", np.random.randn(256) * 0.3 + np.array([0.2, -1.2] + [0] * 254)),
    ("bank", "bank_tilt", np.random.randn(256) * 0.3 + np.array([0.3, -1.0] + [0] * 254)),
    ("bank", "bank_tilt", np.random.randn(256) * 0.3 + np.array([0.1, -1.1] + [0] * 254)),
]

wsd.create_sense_embeddings(bank_examples)

# Test disambiguation with multiple targets
print("\nTesting disambiguation:\n")

test_targets = [
    ("financial_context", np.random.randn(256) * 0.3 + np.array([1.0, 0.4] + [0] * 254)),
    ("river_context", np.random.randn(256) * 0.3 + np.array([-1.0, 0.8] + [0] * 254)),
    ("aviation_context", np.random.randn(256) * 0.3 + np.array([0.2, -1.0] + [0] * 254)),
    ("ambiguous_context", np.random.randn(256) * 0.3 + np.array([0.0, 0.0] + [0] * 254)),
]

predictions = []
for context_name, target_emb in test_targets:
    print(f"\n{context_name}:")
    predicted = wsd.disambiguate(target_emb, "bank")
    predictions.append((context_name, predicted, target_emb))

# Enhanced visualization with all test points
from sklearn.decomposition import PCA

pca = PCA(n_components=2)

# Prepare all embeddings for PCA
all_embeddings = []
labels = []
colors_list = []
markers_list = []

# Add sense centroids
sense_colors = {'bank_financial': 'blue', 'bank_river': 'green', 'bank_tilt': 'orange'}
for sense_id, emb in wsd.sense_embeddings.items():
    all_embeddings.append(emb)
    labels.append(f"{sense_id} (centroid)")
    colors_list.append(sense_colors[sense_id])
    markers_list.append('s')  # square for centroids

# Add individual training examples
for word, sense_id, emb in bank_examples:
    all_embeddings.append(emb)
    labels.append(None)  # Don't label individual points
    colors_list.append(sense_colors[sense_id])
    markers_list.append('o')  # circle for examples

# Add test targets
target_colors = {'financial_context': 'darkblue', 'river_context': 'darkgreen',
                 'aviation_context': 'darkorange', 'ambiguous_context': 'red'}
for context_name, predicted, emb in predictions:
    all_embeddings.append(emb)
    labels.append(f"{context_name}\n->{predicted.split('_')[1]}")
    colors_list.append(target_colors[context_name])
    markers_list.append('X')  # X for test points

# Project to 2D
projected = pca.fit_transform(all_embeddings)

# Plot
plt.figure(figsize=(12, 8))

# Plot points
for i, (x, y) in enumerate(projected):
    if labels[i]:  # Only plot labeled points with labels
        plt.scatter(x, y, c=colors_list[i], s=200 if markers_list[i] != 'o' else 50,
                   marker=markers_list[i], edgecolors='black', linewidths=1.5)
        if markers_list[i] != 'o':  # Add text labels for centroids and targets
            plt.annotate(labels[i], (x, y), xytext=(5, 5), textcoords='offset points',
                        fontsize=9, alpha=0.8)
    else:  # Plot training examples without labels
        plt.scatter(x, y, c=colors_list[i], s=30, marker=markers_list[i], alpha=0.5)

plt.title('Word Sense Disambiguation: "bank" senses and test contexts', fontsize=14)
plt.xlabel(f'PC1 ({pca.explained_variance_ratio_[0]:.1%} variance)')
plt.ylabel(f'PC2 ({pca.explained_variance_ratio_[1]:.1%} variance)')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()


print("=== GRAPH ELEMENTS ===\n")

print("1. SENSE CENTROIDS (large squares):")
print("   - Blue square: 'bank_financial' centroid (average of 4 financial examples)")
print("   - Green square: 'bank_river' centroid (average of 4 river examples)")
print("   - Orange square: 'bank_tilt' centroid (average of 3 aviation examples)")

print("\n2. TRAINING EXAMPLES (small circles, semi-transparent):")
print("   - 4 light blue circles: individual financial bank examples")
print("   - 4 light green circles: individual river bank examples")
print("   - 3 light orange circles: individual tilt/aviation bank examples")

print("\n3. TEST POINTS (large X markers with black edges):")
print("   - Dark blue X: 'financial_context' - should classify as bank_financial")
print("   - Dark green X: 'river_context' - should classify as bank_river")
print("   - Dark orange X: 'aviation_context' - should classify as bank_tilt")
print("   - Red X: 'ambiguous_context' - equidistant from all senses")

print("\n4. VISUAL CLUSTERING:")
print("   - PCA projects 256-dim vectors to 2D")
print("   - Similar embeddings cluster together")
print("   - Distance between points ≈ cosine similarity")
print("   - Axes show % variance explained by each principal component")

print("\n5. DISAMBIGUATION RESULTS:")
print("   - Each test X should be closest to its matching color centroid")
print("   - Ambiguous (red) X sits between clusters, picks nearest")

